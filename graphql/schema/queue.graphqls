type QueueQueryResult {
  jobs(input: QueueJobsQueryInput!): QueueJobsQueryResult!
  metrics(input: QueueMetricsQueryInput!): QueueMetricsQueryResult!
}

input QueueJobsQueryInput {
  queues: [String!]
  statuses: [QueueJobStatus!]
  limit: Int
  page: Int
  offset: Int
  hasNextPage: Boolean
  orderBy: [QueueJobsOrderByInput!]
}

input QueueJobsOrderByInput {
  field: QueueJobsOrderByField!
  descending: Boolean
}

type QueueJob {
  id: ID!
  queue: String!
  status: QueueJobStatus!
  payload: String!
  priority: Int!
  retries: Int!
  maxRetries: Int!
  runAfter: DateTime!
  ranAt: DateTime
  error: String
  createdAt: DateTime!
}

type QueueJobsQueryResult {
  items: [QueueJob!]!
  hasNextPage: Boolean
}

enum QueueJobStatus {
  pending
  retry
  failed
  processed
}

enum QueueMetricsBucketDuration {
  minute
  hour
  day
}

type QueueMetricsBucket {
  queue: String!
  status: QueueJobStatus!
  createdAtBucket: DateTime!
  ranAtBucket: DateTime
  count: Int!
  latency: Duration
}

type QueueMetricsQueryResult {
  buckets: [QueueMetricsBucket!]!
}

input QueueMetricsQueryInput {
  bucketDuration: QueueMetricsBucketDuration!
  statuses: [QueueJobStatus!]
  queues: [String!]
  startTime: DateTime
  endTime: DateTime
}

type QueueMutation {
  purgeJobs(input: QueuePurgeJobsInput!): Void
  enqueueReprocessTorrentsBatch(input: QueueEnqueueReprocessTorrentsBatchInput): Void
}

input QueuePurgeJobsInput {
  queues: [String!]
  statuses: [QueueJobStatus!]
}

input QueueEnqueueReprocessTorrentsBatchInput {
  batchSize: Int
  chunkSize: Int
  contentTypes: [ContentType]
  orphans: Boolean
  classifierRematch: Boolean
  classifierWorkflow: String
  apisDisabled: Boolean
  localSearchDisabled: Boolean
}
