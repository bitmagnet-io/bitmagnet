// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/bitmagnet-io/bitmagnet/internal/model"
)

func newTorrentContent(db *gorm.DB, opts ...gen.DOOption) torrentContent {
	_torrentContent := torrentContent{}

	_torrentContent.torrentContentDo.UseDB(db, opts...)
	_torrentContent.torrentContentDo.UseModel(&model.TorrentContent{})

	tableName := _torrentContent.torrentContentDo.TableName()
	_torrentContent.ALL = field.NewAsterisk(tableName)
	_torrentContent.ID = field.NewString(tableName, "id")
	_torrentContent.InfoHash = field.NewField(tableName, "info_hash")
	_torrentContent.ContentType = field.NewString(tableName, "content_type")
	_torrentContent.ContentSource = field.NewString(tableName, "content_source")
	_torrentContent.ContentID = field.NewString(tableName, "content_id")
	_torrentContent.Languages = field.NewField(tableName, "languages")
	_torrentContent.Episodes = field.NewField(tableName, "episodes")
	_torrentContent.VideoResolution = field.NewField(tableName, "video_resolution")
	_torrentContent.VideoSource = field.NewField(tableName, "video_source")
	_torrentContent.VideoCodec = field.NewField(tableName, "video_codec")
	_torrentContent.Video3D = field.NewField(tableName, "video_3d")
	_torrentContent.VideoModifier = field.NewField(tableName, "video_modifier")
	_torrentContent.ReleaseGroup = field.NewField(tableName, "release_group")
	_torrentContent.CreatedAt = field.NewTime(tableName, "created_at")
	_torrentContent.UpdatedAt = field.NewTime(tableName, "updated_at")
	_torrentContent.Tsv = field.NewField(tableName, "tsv")
	_torrentContent.Seeders = field.NewField(tableName, "seeders")
	_torrentContent.Leechers = field.NewField(tableName, "leechers")
	_torrentContent.PublishedAt = field.NewTime(tableName, "published_at")
	_torrentContent.Size = field.NewUint(tableName, "size")
	_torrentContent.FilesCount = field.NewField(tableName, "files_count")
	_torrentContent.Torrent = torrentContentBelongsToTorrent{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Torrent", "model.Torrent"),
		Hint: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Torrent.Hint", "model.TorrentHint"),
		},
		Contents: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Torrent.Contents", "model.TorrentContent"),
		},
		Sources: struct {
			field.RelationField
			TorrentSource struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Torrent.Sources", "model.TorrentsTorrentSource"),
			TorrentSource: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Torrent.Sources.TorrentSource", "model.TorrentSource"),
			},
		},
		Files: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Torrent.Files", "model.TorrentFile"),
		},
		Pieces: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Torrent.Pieces", "model.TorrentPieces"),
		},
		Tags: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Torrent.Tags", "model.TorrentTag"),
		},
	}

	_torrentContent.Content = torrentContentBelongsToContent{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Content", "model.Content"),
		Collections: struct {
			field.RelationField
			MetadataSource struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Content.Collections", "model.ContentCollection"),
			MetadataSource: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Content.Collections.MetadataSource", "model.MetadataSource"),
			},
		},
		Attributes: struct {
			field.RelationField
			MetadataSource struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Content.Attributes", "model.ContentAttribute"),
			MetadataSource: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Content.Attributes.MetadataSource", "model.MetadataSource"),
			},
		},
		MetadataSource: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Content.MetadataSource", "model.MetadataSource"),
		},
	}

	_torrentContent.fillFieldMap()

	return _torrentContent
}

type torrentContent struct {
	torrentContentDo

	ALL             field.Asterisk
	ID              field.String
	InfoHash        field.Field
	ContentType     field.String
	ContentSource   field.String
	ContentID       field.String
	Languages       field.Field
	Episodes        field.Field
	VideoResolution field.Field
	VideoSource     field.Field
	VideoCodec      field.Field
	Video3D         field.Field
	VideoModifier   field.Field
	ReleaseGroup    field.Field
	CreatedAt       field.Time
	UpdatedAt       field.Time
	Tsv             field.Field
	Seeders         field.Field
	Leechers        field.Field
	PublishedAt     field.Time
	Size            field.Uint
	FilesCount      field.Field
	Torrent         torrentContentBelongsToTorrent

	Content torrentContentBelongsToContent

	fieldMap map[string]field.Expr
}

func (t torrentContent) Table(newTableName string) *torrentContent {
	t.torrentContentDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t torrentContent) As(alias string) *torrentContent {
	t.torrentContentDo.DO = *(t.torrentContentDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *torrentContent) updateTableName(table string) *torrentContent {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewString(table, "id")
	t.InfoHash = field.NewField(table, "info_hash")
	t.ContentType = field.NewString(table, "content_type")
	t.ContentSource = field.NewString(table, "content_source")
	t.ContentID = field.NewString(table, "content_id")
	t.Languages = field.NewField(table, "languages")
	t.Episodes = field.NewField(table, "episodes")
	t.VideoResolution = field.NewField(table, "video_resolution")
	t.VideoSource = field.NewField(table, "video_source")
	t.VideoCodec = field.NewField(table, "video_codec")
	t.Video3D = field.NewField(table, "video_3d")
	t.VideoModifier = field.NewField(table, "video_modifier")
	t.ReleaseGroup = field.NewField(table, "release_group")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.Tsv = field.NewField(table, "tsv")
	t.Seeders = field.NewField(table, "seeders")
	t.Leechers = field.NewField(table, "leechers")
	t.PublishedAt = field.NewTime(table, "published_at")
	t.Size = field.NewUint(table, "size")
	t.FilesCount = field.NewField(table, "files_count")

	t.fillFieldMap()

	return t
}

func (t *torrentContent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *torrentContent) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 23)
	t.fieldMap["id"] = t.ID
	t.fieldMap["info_hash"] = t.InfoHash
	t.fieldMap["content_type"] = t.ContentType
	t.fieldMap["content_source"] = t.ContentSource
	t.fieldMap["content_id"] = t.ContentID
	t.fieldMap["languages"] = t.Languages
	t.fieldMap["episodes"] = t.Episodes
	t.fieldMap["video_resolution"] = t.VideoResolution
	t.fieldMap["video_source"] = t.VideoSource
	t.fieldMap["video_codec"] = t.VideoCodec
	t.fieldMap["video_3d"] = t.Video3D
	t.fieldMap["video_modifier"] = t.VideoModifier
	t.fieldMap["release_group"] = t.ReleaseGroup
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["tsv"] = t.Tsv
	t.fieldMap["seeders"] = t.Seeders
	t.fieldMap["leechers"] = t.Leechers
	t.fieldMap["published_at"] = t.PublishedAt
	t.fieldMap["size"] = t.Size
	t.fieldMap["files_count"] = t.FilesCount

}

func (t torrentContent) clone(db *gorm.DB) torrentContent {
	t.torrentContentDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t torrentContent) replaceDB(db *gorm.DB) torrentContent {
	t.torrentContentDo.ReplaceDB(db)
	return t
}

type torrentContentBelongsToTorrent struct {
	db *gorm.DB

	field.RelationField

	Hint struct {
		field.RelationField
	}
	Contents struct {
		field.RelationField
	}
	Sources struct {
		field.RelationField
		TorrentSource struct {
			field.RelationField
		}
	}
	Files struct {
		field.RelationField
	}
	Pieces struct {
		field.RelationField
	}
	Tags struct {
		field.RelationField
	}
}

func (a torrentContentBelongsToTorrent) Where(conds ...field.Expr) *torrentContentBelongsToTorrent {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a torrentContentBelongsToTorrent) WithContext(ctx context.Context) *torrentContentBelongsToTorrent {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a torrentContentBelongsToTorrent) Session(session *gorm.Session) *torrentContentBelongsToTorrent {
	a.db = a.db.Session(session)
	return &a
}

func (a torrentContentBelongsToTorrent) Model(m *model.TorrentContent) *torrentContentBelongsToTorrentTx {
	return &torrentContentBelongsToTorrentTx{a.db.Model(m).Association(a.Name())}
}

type torrentContentBelongsToTorrentTx struct{ tx *gorm.Association }

func (a torrentContentBelongsToTorrentTx) Find() (result *model.Torrent, err error) {
	return result, a.tx.Find(&result)
}

func (a torrentContentBelongsToTorrentTx) Append(values ...*model.Torrent) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a torrentContentBelongsToTorrentTx) Replace(values ...*model.Torrent) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a torrentContentBelongsToTorrentTx) Delete(values ...*model.Torrent) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a torrentContentBelongsToTorrentTx) Clear() error {
	return a.tx.Clear()
}

func (a torrentContentBelongsToTorrentTx) Count() int64 {
	return a.tx.Count()
}

type torrentContentBelongsToContent struct {
	db *gorm.DB

	field.RelationField

	Collections struct {
		field.RelationField
		MetadataSource struct {
			field.RelationField
		}
	}
	Attributes struct {
		field.RelationField
		MetadataSource struct {
			field.RelationField
		}
	}
	MetadataSource struct {
		field.RelationField
	}
}

func (a torrentContentBelongsToContent) Where(conds ...field.Expr) *torrentContentBelongsToContent {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a torrentContentBelongsToContent) WithContext(ctx context.Context) *torrentContentBelongsToContent {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a torrentContentBelongsToContent) Session(session *gorm.Session) *torrentContentBelongsToContent {
	a.db = a.db.Session(session)
	return &a
}

func (a torrentContentBelongsToContent) Model(m *model.TorrentContent) *torrentContentBelongsToContentTx {
	return &torrentContentBelongsToContentTx{a.db.Model(m).Association(a.Name())}
}

type torrentContentBelongsToContentTx struct{ tx *gorm.Association }

func (a torrentContentBelongsToContentTx) Find() (result *model.Content, err error) {
	return result, a.tx.Find(&result)
}

func (a torrentContentBelongsToContentTx) Append(values ...*model.Content) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a torrentContentBelongsToContentTx) Replace(values ...*model.Content) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a torrentContentBelongsToContentTx) Delete(values ...*model.Content) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a torrentContentBelongsToContentTx) Clear() error {
	return a.tx.Clear()
}

func (a torrentContentBelongsToContentTx) Count() int64 {
	return a.tx.Count()
}

type torrentContentDo struct{ gen.DO }

type ITorrentContentDo interface {
	gen.SubQuery
	Debug() ITorrentContentDo
	WithContext(ctx context.Context) ITorrentContentDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITorrentContentDo
	WriteDB() ITorrentContentDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITorrentContentDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITorrentContentDo
	Not(conds ...gen.Condition) ITorrentContentDo
	Or(conds ...gen.Condition) ITorrentContentDo
	Select(conds ...field.Expr) ITorrentContentDo
	Where(conds ...gen.Condition) ITorrentContentDo
	Order(conds ...field.Expr) ITorrentContentDo
	Distinct(cols ...field.Expr) ITorrentContentDo
	Omit(cols ...field.Expr) ITorrentContentDo
	Join(table schema.Tabler, on ...field.Expr) ITorrentContentDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITorrentContentDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITorrentContentDo
	Group(cols ...field.Expr) ITorrentContentDo
	Having(conds ...gen.Condition) ITorrentContentDo
	Limit(limit int) ITorrentContentDo
	Offset(offset int) ITorrentContentDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITorrentContentDo
	Unscoped() ITorrentContentDo
	Create(values ...*model.TorrentContent) error
	CreateInBatches(values []*model.TorrentContent, batchSize int) error
	Save(values ...*model.TorrentContent) error
	First() (*model.TorrentContent, error)
	Take() (*model.TorrentContent, error)
	Last() (*model.TorrentContent, error)
	Find() ([]*model.TorrentContent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TorrentContent, err error)
	FindInBatches(result *[]*model.TorrentContent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TorrentContent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITorrentContentDo
	Assign(attrs ...field.AssignExpr) ITorrentContentDo
	Joins(fields ...field.RelationField) ITorrentContentDo
	Preload(fields ...field.RelationField) ITorrentContentDo
	FirstOrInit() (*model.TorrentContent, error)
	FirstOrCreate() (*model.TorrentContent, error)
	FindByPage(offset int, limit int) (result []*model.TorrentContent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITorrentContentDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t torrentContentDo) Debug() ITorrentContentDo {
	return t.withDO(t.DO.Debug())
}

func (t torrentContentDo) WithContext(ctx context.Context) ITorrentContentDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t torrentContentDo) ReadDB() ITorrentContentDo {
	return t.Clauses(dbresolver.Read)
}

func (t torrentContentDo) WriteDB() ITorrentContentDo {
	return t.Clauses(dbresolver.Write)
}

func (t torrentContentDo) Session(config *gorm.Session) ITorrentContentDo {
	return t.withDO(t.DO.Session(config))
}

func (t torrentContentDo) Clauses(conds ...clause.Expression) ITorrentContentDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t torrentContentDo) Returning(value interface{}, columns ...string) ITorrentContentDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t torrentContentDo) Not(conds ...gen.Condition) ITorrentContentDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t torrentContentDo) Or(conds ...gen.Condition) ITorrentContentDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t torrentContentDo) Select(conds ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t torrentContentDo) Where(conds ...gen.Condition) ITorrentContentDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t torrentContentDo) Order(conds ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t torrentContentDo) Distinct(cols ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t torrentContentDo) Omit(cols ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t torrentContentDo) Join(table schema.Tabler, on ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t torrentContentDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t torrentContentDo) RightJoin(table schema.Tabler, on ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t torrentContentDo) Group(cols ...field.Expr) ITorrentContentDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t torrentContentDo) Having(conds ...gen.Condition) ITorrentContentDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t torrentContentDo) Limit(limit int) ITorrentContentDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t torrentContentDo) Offset(offset int) ITorrentContentDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t torrentContentDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITorrentContentDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t torrentContentDo) Unscoped() ITorrentContentDo {
	return t.withDO(t.DO.Unscoped())
}

func (t torrentContentDo) Create(values ...*model.TorrentContent) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t torrentContentDo) CreateInBatches(values []*model.TorrentContent, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t torrentContentDo) Save(values ...*model.TorrentContent) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t torrentContentDo) First() (*model.TorrentContent, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TorrentContent), nil
	}
}

func (t torrentContentDo) Take() (*model.TorrentContent, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TorrentContent), nil
	}
}

func (t torrentContentDo) Last() (*model.TorrentContent, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TorrentContent), nil
	}
}

func (t torrentContentDo) Find() ([]*model.TorrentContent, error) {
	result, err := t.DO.Find()
	return result.([]*model.TorrentContent), err
}

func (t torrentContentDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TorrentContent, err error) {
	buf := make([]*model.TorrentContent, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t torrentContentDo) FindInBatches(result *[]*model.TorrentContent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t torrentContentDo) Attrs(attrs ...field.AssignExpr) ITorrentContentDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t torrentContentDo) Assign(attrs ...field.AssignExpr) ITorrentContentDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t torrentContentDo) Joins(fields ...field.RelationField) ITorrentContentDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t torrentContentDo) Preload(fields ...field.RelationField) ITorrentContentDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t torrentContentDo) FirstOrInit() (*model.TorrentContent, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TorrentContent), nil
	}
}

func (t torrentContentDo) FirstOrCreate() (*model.TorrentContent, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TorrentContent), nil
	}
}

func (t torrentContentDo) FindByPage(offset int, limit int) (result []*model.TorrentContent, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t torrentContentDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t torrentContentDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t torrentContentDo) Delete(models ...*model.TorrentContent) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *torrentContentDo) withDO(do gen.Dao) *torrentContentDo {
	t.DO = *do.(*gen.DO)
	return t
}
