package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"

	q "github.com/bitmagnet-io/bitmagnet/internal/database/query"
	"github.com/bitmagnet-io/bitmagnet/internal/database/search"
	"github.com/bitmagnet-io/bitmagnet/internal/gql"
	"github.com/bitmagnet-io/bitmagnet/internal/gql/gqlmodel"
	"github.com/bitmagnet-io/bitmagnet/internal/gql/gqlmodel/gen"
)

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context) (gqlmodel.SearchQuery, error) {
	return gqlmodel.SearchQuery{}, nil
}

// TorrentContent is the resolver for the torrentContent field.
func (r *searchQueryResolver) TorrentContent(ctx context.Context, obj *gqlmodel.SearchQuery, query *q.SearchParams, facets *gen.TorrentContentFacetsInput) (q.GenericResult[search.TorrentContentResultItem], error) {
	options := []q.Option{
		search.TorrentContentDefaultOption(),
	}
	if query != nil {
		options = append(options, query.Option())
	}
	if facets != nil {
		var qFacets []q.Facet
		if contentType, ok := facets.ContentType.ValueOK(); ok {
			qFacets = append(qFacets, torrentContentTypeFacet(*contentType))
		}
		if torrentSource, ok := facets.TorrentSource.ValueOK(); ok {
			qFacets = append(qFacets, torrentSourceFacet(*torrentSource))
		}
		if torrentFileType, ok := facets.TorrentFileType.ValueOK(); ok {
			qFacets = append(qFacets, torrentFileTypeFacet(*torrentFileType))
		}
		if language, ok := facets.Language.ValueOK(); ok {
			qFacets = append(qFacets, languageFacet(*language))
		}
		if genre, ok := facets.Genre.ValueOK(); ok {
			qFacets = append(qFacets, genreFacet(*genre))
		}
		if releaseYear, ok := facets.ReleaseYear.ValueOK(); ok {
			qFacets = append(qFacets, releaseYearFacet(*releaseYear))
		}
		if videoResolution, ok := facets.VideoResolution.ValueOK(); ok {
			qFacets = append(qFacets, videoResolutionFacet(*videoResolution))
		}
		if videoSource, ok := facets.VideoSource.ValueOK(); ok {
			qFacets = append(qFacets, videoSourceFacet(*videoSource))
		}
		options = append(options, q.WithFacet(qFacets...))
	}
	return r.search.TorrentContent(ctx, options...)
}

// Items is the resolver for the items field.
func (r *torrentContentResultResolver) Items(ctx context.Context, obj *q.GenericResult[search.TorrentContentResultItem]) ([]gqlmodel.TorrentContent, error) {
	items := make([]gqlmodel.TorrentContent, 0, len(obj.Items))
	for _, item := range obj.Items {
		items = append(items, gqlmodel.NewTorrentContentFromResultItem(item))
	}
	return items, nil
}

// Aggregations is the resolver for the aggregations field.
func (r *torrentContentResultResolver) Aggregations(ctx context.Context, obj *q.GenericResult[search.TorrentContentResultItem]) (gen.TorrentContentAggregations, error) {
	a := gen.TorrentContentAggregations{}
	if contentTypes, ok := obj.Aggregations[search.TorrentContentTypeFacetKey]; ok {
		aggs, err := contentTypeAggs(contentTypes.Items)
		if err != nil {
			return a, err
		}
		a.ContentType = aggs
	}
	if torrentSources, ok := obj.Aggregations[search.TorrentSourceFacetKey]; ok {
		aggs, err := torrentSourceAggs(torrentSources.Items)
		if err != nil {
			return a, err
		}
		a.TorrentSource = aggs
	}
	if fileTypes, ok := obj.Aggregations[search.TorrentFileTypeFacetKey]; ok {
		aggs, err := torrentFileTypeAggs(fileTypes.Items)
		if err != nil {
			return a, err
		}
		a.TorrentFileType = aggs
	}
	if languages, ok := obj.Aggregations[search.LanguageFacetKey]; ok {
		aggs, err := languageAggs(languages.Items)
		if err != nil {
			return a, err
		}
		a.Language = aggs
	}
	if genres, ok := obj.Aggregations[search.ContentGenreFacetKey]; ok {
		aggs, err := genreAggs(genres.Items)
		if err != nil {
			return a, err
		}
		a.Genre = aggs
	}
	if releaseYears, ok := obj.Aggregations[search.ReleaseYearFacetKey]; ok {
		aggs, err := releaseYearAggs(releaseYears.Items)
		if err != nil {
			return a, err
		}
		a.ReleaseYear = aggs
	}
	if videoResolutions, ok := obj.Aggregations[search.VideoResolutionFacetKey]; ok {
		aggs, err := videoResolutionAggs(videoResolutions.Items)
		if err != nil {
			return a, err
		}
		a.VideoResolution = aggs
	}
	if videoSource, ok := obj.Aggregations[search.VideoSourceFacetKey]; ok {
		aggs, err := videoSourceAggs(videoSource.Items)
		if err != nil {
			return a, err
		}
		a.VideoSource = aggs
	}
	return a, nil
}

// SearchQuery returns gql.SearchQueryResolver implementation.
func (r *Resolver) SearchQuery() gql.SearchQueryResolver { return &searchQueryResolver{r} }

// TorrentContentResult returns gql.TorrentContentResultResolver implementation.
func (r *Resolver) TorrentContentResult() gql.TorrentContentResultResolver {
	return &torrentContentResultResolver{r}
}

type searchQueryResolver struct{ *Resolver }
type torrentContentResultResolver struct{ *Resolver }
