package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"sort"

	"github.com/bitmagnet-io/bitmagnet/internal/gql"
	"github.com/bitmagnet-io/bitmagnet/internal/gql/gqlmodel"
	"github.com/bitmagnet-io/bitmagnet/internal/gql/gqlmodel/gen"
	"github.com/bitmagnet-io/bitmagnet/internal/health"
	"github.com/bitmagnet-io/bitmagnet/internal/version"
)

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context) (string, error) {
	return version.GitTag, nil
}

// Workers is the resolver for the workers field.
func (r *queryResolver) Workers(ctx context.Context) (gen.WorkersQuery, error) {
	var workers []gen.Worker
	for _, w := range r.Resolver.Workers.Workers() {
		workers = append(workers, gen.Worker{
			Key:     w.Key(),
			Started: w.Started(),
		})
	}
	return gen.WorkersQuery{
		All: workers,
	}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (gen.HealthQuery, error) {
	transformHealthCheckStatus := func(s health.AvailabilityStatus) gen.HealthStatus {
		switch s {
		case health.StatusInactive:
			return gen.HealthStatusInactive
		case health.StatusDown:
			return gen.HealthStatusDown
		case health.StatusUp:
			return gen.HealthStatusUp
		default:
			return gen.HealthStatusUnknown
		}
	}
	check := r.Checker.Check(ctx)
	checks := make([]gen.HealthCheck, 0, len(check.Details))
	for k, v := range check.Details {
		var err *string
		if v.Error != nil {
			strErr := v.Error.Error()
			err = &strErr
		}
		checks = append(checks, gen.HealthCheck{
			Key:       k,
			Status:    transformHealthCheckStatus(v.Status),
			Timestamp: v.Timestamp,
			Error:     err,
		})
	}
	sort.Slice(checks, func(i, j int) bool {
		return checks[i].Key < checks[j].Key
	})
	result := gen.HealthQuery{
		Status: transformHealthCheckStatus(check.Status),
		Checks: checks,
	}
	return result, nil
}

// Queue is the resolver for the queue field.
func (r *queryResolver) Queue(ctx context.Context) (gqlmodel.QueueQuery, error) {
	return gqlmodel.QueueQuery{QueueMetricsClient: r.QueueMetricsClient}, nil
}

// Torrent is the resolver for the torrent field.
func (r *queryResolver) Torrent(ctx context.Context) (gqlmodel.TorrentQuery, error) {
	return gqlmodel.TorrentQuery{
		TorrentSearch: r.Search,
	}, nil
}

// TorrentContent is the resolver for the torrentContent field.
func (r *queryResolver) TorrentContent(ctx context.Context) (gqlmodel.TorrentContentQuery, error) {
	return gqlmodel.TorrentContentQuery{
		TorrentContentSearch: r.Search,
	}, nil
}

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
