// Code generated by mockery v2.35.2. DO NOT EDIT.

package ktable_mocks

import (
	ktable "github.com/bitmagnet-io/bitmagnet/internal/protocol/dht/ktable"
	mock "github.com/stretchr/testify/mock"

	netip "net/netip"

	protocol "github.com/bitmagnet-io/bitmagnet/internal/protocol"

	time "time"
)

// Table is an autogenerated mock type for the Table type
type Table struct {
	mock.Mock
}

type Table_Expecter struct {
	mock *mock.Mock
}

func (_m *Table) EXPECT() *Table_Expecter {
	return &Table_Expecter{mock: &_m.Mock}
}

// DropAddr provides a mock function with given fields: addr, reason
func (_m *Table) DropAddr(addr netip.Addr, reason error) bool {
	ret := _m.Called(addr, reason)

	var r0 bool
	if rf, ok := ret.Get(0).(func(netip.Addr, error) bool); ok {
		r0 = rf(addr, reason)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Table_DropAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropAddr'
type Table_DropAddr_Call struct {
	*mock.Call
}

// DropAddr is a helper method to define mock.On call
//   - addr netip.Addr
//   - reason error
func (_e *Table_Expecter) DropAddr(addr interface{}, reason interface{}) *Table_DropAddr_Call {
	return &Table_DropAddr_Call{Call: _e.mock.On("DropAddr", addr, reason)}
}

func (_c *Table_DropAddr_Call) Run(run func(addr netip.Addr, reason error)) *Table_DropAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(netip.Addr), args[1].(error))
	})
	return _c
}

func (_c *Table_DropAddr_Call) Return(_a0 bool) *Table_DropAddr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_DropAddr_Call) RunAndReturn(run func(netip.Addr, error) bool) *Table_DropAddr_Call {
	_c.Call.Return(run)
	return _c
}

// DropPeer provides a mock function with given fields: id, reason
func (_m *Table) DropPeer(id protocol.ID, reason error) bool {
	ret := _m.Called(id, reason)

	var r0 bool
	if rf, ok := ret.Get(0).(func(protocol.ID, error) bool); ok {
		r0 = rf(id, reason)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Table_DropPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropPeer'
type Table_DropPeer_Call struct {
	*mock.Call
}

// DropPeer is a helper method to define mock.On call
//   - id protocol.ID
//   - reason error
func (_e *Table_Expecter) DropPeer(id interface{}, reason interface{}) *Table_DropPeer_Call {
	return &Table_DropPeer_Call{Call: _e.mock.On("DropPeer", id, reason)}
}

func (_c *Table_DropPeer_Call) Run(run func(id protocol.ID, reason error)) *Table_DropPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID), args[1].(error))
	})
	return _c
}

func (_c *Table_DropPeer_Call) Return(_a0 bool) *Table_DropPeer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_DropPeer_Call) RunAndReturn(run func(protocol.ID, error) bool) *Table_DropPeer_Call {
	_c.Call.Return(run)
	return _c
}

// GeneratePeerID provides a mock function with given fields:
func (_m *Table) GeneratePeerID() protocol.ID {
	ret := _m.Called()

	var r0 protocol.ID
	if rf, ok := ret.Get(0).(func() protocol.ID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.ID)
		}
	}

	return r0
}

// Table_GeneratePeerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeneratePeerID'
type Table_GeneratePeerID_Call struct {
	*mock.Call
}

// GeneratePeerID is a helper method to define mock.On call
func (_e *Table_Expecter) GeneratePeerID() *Table_GeneratePeerID_Call {
	return &Table_GeneratePeerID_Call{Call: _e.mock.On("GeneratePeerID")}
}

func (_c *Table_GeneratePeerID_Call) Run(run func()) *Table_GeneratePeerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Table_GeneratePeerID_Call) Return(_a0 protocol.ID) *Table_GeneratePeerID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_GeneratePeerID_Call) RunAndReturn(run func() protocol.ID) *Table_GeneratePeerID_Call {
	_c.Call.Return(run)
	return _c
}

// GetClosestPeers provides a mock function with given fields: id
func (_m *Table) GetClosestPeers(id protocol.ID) []ktable.Peer {
	ret := _m.Called(id)

	var r0 []ktable.Peer
	if rf, ok := ret.Get(0).(func(protocol.ID) []ktable.Peer); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ktable.Peer)
		}
	}

	return r0
}

// Table_GetClosestPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClosestPeers'
type Table_GetClosestPeers_Call struct {
	*mock.Call
}

// GetClosestPeers is a helper method to define mock.On call
//   - id protocol.ID
func (_e *Table_Expecter) GetClosestPeers(id interface{}) *Table_GetClosestPeers_Call {
	return &Table_GetClosestPeers_Call{Call: _e.mock.On("GetClosestPeers", id)}
}

func (_c *Table_GetClosestPeers_Call) Run(run func(id protocol.ID)) *Table_GetClosestPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID))
	})
	return _c
}

func (_c *Table_GetClosestPeers_Call) Return(_a0 []ktable.Peer) *Table_GetClosestPeers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_GetClosestPeers_Call) RunAndReturn(run func(protocol.ID) []ktable.Peer) *Table_GetClosestPeers_Call {
	_c.Call.Return(run)
	return _c
}

// GetHash provides a mock function with given fields: id
func (_m *Table) GetHash(id protocol.ID) (ktable.Hash, bool) {
	ret := _m.Called(id)

	var r0 ktable.Hash
	var r1 bool
	if rf, ok := ret.Get(0).(func(protocol.ID) (ktable.Hash, bool)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(protocol.ID) ktable.Hash); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ktable.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(protocol.ID) bool); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Table_GetHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHash'
type Table_GetHash_Call struct {
	*mock.Call
}

// GetHash is a helper method to define mock.On call
//   - id protocol.ID
func (_e *Table_Expecter) GetHash(id interface{}) *Table_GetHash_Call {
	return &Table_GetHash_Call{Call: _e.mock.On("GetHash", id)}
}

func (_c *Table_GetHash_Call) Run(run func(id protocol.ID)) *Table_GetHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID))
	})
	return _c
}

func (_c *Table_GetHash_Call) Return(_a0 ktable.Hash, _a1 bool) *Table_GetHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Table_GetHash_Call) RunAndReturn(run func(protocol.ID) (ktable.Hash, bool)) *Table_GetHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetHashOrClosestPeers provides a mock function with given fields: id
func (_m *Table) GetHashOrClosestPeers(id protocol.ID) (ktable.Hash, []ktable.Peer, bool) {
	ret := _m.Called(id)

	var r0 ktable.Hash
	var r1 []ktable.Peer
	var r2 bool
	if rf, ok := ret.Get(0).(func(protocol.ID) (ktable.Hash, []ktable.Peer, bool)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(protocol.ID) ktable.Hash); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ktable.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(protocol.ID) []ktable.Peer); ok {
		r1 = rf(id)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]ktable.Peer)
		}
	}

	if rf, ok := ret.Get(2).(func(protocol.ID) bool); ok {
		r2 = rf(id)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// Table_GetHashOrClosestPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHashOrClosestPeers'
type Table_GetHashOrClosestPeers_Call struct {
	*mock.Call
}

// GetHashOrClosestPeers is a helper method to define mock.On call
//   - id protocol.ID
func (_e *Table_Expecter) GetHashOrClosestPeers(id interface{}) *Table_GetHashOrClosestPeers_Call {
	return &Table_GetHashOrClosestPeers_Call{Call: _e.mock.On("GetHashOrClosestPeers", id)}
}

func (_c *Table_GetHashOrClosestPeers_Call) Run(run func(id protocol.ID)) *Table_GetHashOrClosestPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID))
	})
	return _c
}

func (_c *Table_GetHashOrClosestPeers_Call) Return(_a0 ktable.Hash, _a1 []ktable.Peer, _a2 bool) *Table_GetHashOrClosestPeers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Table_GetHashOrClosestPeers_Call) RunAndReturn(run func(protocol.ID) (ktable.Hash, []ktable.Peer, bool)) *Table_GetHashOrClosestPeers_Call {
	_c.Call.Return(run)
	return _c
}

// GetOldestPeers provides a mock function with given fields: cutoff, n
func (_m *Table) GetOldestPeers(cutoff time.Time, n int) []ktable.Peer {
	ret := _m.Called(cutoff, n)

	var r0 []ktable.Peer
	if rf, ok := ret.Get(0).(func(time.Time, int) []ktable.Peer); ok {
		r0 = rf(cutoff, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ktable.Peer)
		}
	}

	return r0
}

// Table_GetOldestPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOldestPeers'
type Table_GetOldestPeers_Call struct {
	*mock.Call
}

// GetOldestPeers is a helper method to define mock.On call
//   - cutoff time.Time
//   - n int
func (_e *Table_Expecter) GetOldestPeers(cutoff interface{}, n interface{}) *Table_GetOldestPeers_Call {
	return &Table_GetOldestPeers_Call{Call: _e.mock.On("GetOldestPeers", cutoff, n)}
}

func (_c *Table_GetOldestPeers_Call) Run(run func(cutoff time.Time, n int)) *Table_GetOldestPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time), args[1].(int))
	})
	return _c
}

func (_c *Table_GetOldestPeers_Call) Return(_a0 []ktable.Peer) *Table_GetOldestPeers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_GetOldestPeers_Call) RunAndReturn(run func(time.Time, int) []ktable.Peer) *Table_GetOldestPeers_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeer provides a mock function with given fields: id
func (_m *Table) GetPeer(id protocol.ID) (ktable.Peer, bool) {
	ret := _m.Called(id)

	var r0 ktable.Peer
	var r1 bool
	if rf, ok := ret.Get(0).(func(protocol.ID) (ktable.Peer, bool)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(protocol.ID) ktable.Peer); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ktable.Peer)
		}
	}

	if rf, ok := ret.Get(1).(func(protocol.ID) bool); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Table_GetPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeer'
type Table_GetPeer_Call struct {
	*mock.Call
}

// GetPeer is a helper method to define mock.On call
//   - id protocol.ID
func (_e *Table_Expecter) GetPeer(id interface{}) *Table_GetPeer_Call {
	return &Table_GetPeer_Call{Call: _e.mock.On("GetPeer", id)}
}

func (_c *Table_GetPeer_Call) Run(run func(id protocol.ID)) *Table_GetPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID))
	})
	return _c
}

func (_c *Table_GetPeer_Call) Return(_a0 ktable.Peer, _a1 bool) *Table_GetPeer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Table_GetPeer_Call) RunAndReturn(run func(protocol.ID) (ktable.Peer, bool)) *Table_GetPeer_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeerByAddr provides a mock function with given fields: addr
func (_m *Table) GetPeerByAddr(addr netip.Addr) (ktable.Peer, bool) {
	ret := _m.Called(addr)

	var r0 ktable.Peer
	var r1 bool
	if rf, ok := ret.Get(0).(func(netip.Addr) (ktable.Peer, bool)); ok {
		return rf(addr)
	}
	if rf, ok := ret.Get(0).(func(netip.Addr) ktable.Peer); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ktable.Peer)
		}
	}

	if rf, ok := ret.Get(1).(func(netip.Addr) bool); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// Table_GetPeerByAddr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeerByAddr'
type Table_GetPeerByAddr_Call struct {
	*mock.Call
}

// GetPeerByAddr is a helper method to define mock.On call
//   - addr netip.Addr
func (_e *Table_Expecter) GetPeerByAddr(addr interface{}) *Table_GetPeerByAddr_Call {
	return &Table_GetPeerByAddr_Call{Call: _e.mock.On("GetPeerByAddr", addr)}
}

func (_c *Table_GetPeerByAddr_Call) Run(run func(addr netip.Addr)) *Table_GetPeerByAddr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(netip.Addr))
	})
	return _c
}

func (_c *Table_GetPeerByAddr_Call) Return(_a0 ktable.Peer, _a1 bool) *Table_GetPeerByAddr_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Table_GetPeerByAddr_Call) RunAndReturn(run func(netip.Addr) (ktable.Peer, bool)) *Table_GetPeerByAddr_Call {
	_c.Call.Return(run)
	return _c
}

// GetPeersForSampleInfoHashes provides a mock function with given fields: n
func (_m *Table) GetPeersForSampleInfoHashes(n int) []ktable.Peer {
	ret := _m.Called(n)

	var r0 []ktable.Peer
	if rf, ok := ret.Get(0).(func(int) []ktable.Peer); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ktable.Peer)
		}
	}

	return r0
}

// Table_GetPeersForSampleInfoHashes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPeersForSampleInfoHashes'
type Table_GetPeersForSampleInfoHashes_Call struct {
	*mock.Call
}

// GetPeersForSampleInfoHashes is a helper method to define mock.On call
//   - n int
func (_e *Table_Expecter) GetPeersForSampleInfoHashes(n interface{}) *Table_GetPeersForSampleInfoHashes_Call {
	return &Table_GetPeersForSampleInfoHashes_Call{Call: _e.mock.On("GetPeersForSampleInfoHashes", n)}
}

func (_c *Table_GetPeersForSampleInfoHashes_Call) Run(run func(n int)) *Table_GetPeersForSampleInfoHashes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Table_GetPeersForSampleInfoHashes_Call) Return(_a0 []ktable.Peer) *Table_GetPeersForSampleInfoHashes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_GetPeersForSampleInfoHashes_Call) RunAndReturn(run func(int) []ktable.Peer) *Table_GetPeersForSampleInfoHashes_Call {
	_c.Call.Return(run)
	return _c
}

// Origin provides a mock function with given fields:
func (_m *Table) Origin() protocol.ID {
	ret := _m.Called()

	var r0 protocol.ID
	if rf, ok := ret.Get(0).(func() protocol.ID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(protocol.ID)
		}
	}

	return r0
}

// Table_Origin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'origin'
type Table_Origin_Call struct {
	*mock.Call
}

// Origin is a helper method to define mock.On call
func (_e *Table_Expecter) Origin() *Table_Origin_Call {
	return &Table_Origin_Call{Call: _e.mock.On("origin")}
}

func (_c *Table_Origin_Call) Run(run func()) *Table_Origin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Table_Origin_Call) Return(_a0 protocol.ID) *Table_Origin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_Origin_Call) RunAndReturn(run func() protocol.ID) *Table_Origin_Call {
	_c.Call.Return(run)
	return _c
}

// PeersCount provides a mock function with given fields:
func (_m *Table) PeersCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Table_PeersCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeersCount'
type Table_PeersCount_Call struct {
	*mock.Call
}

// PeersCount is a helper method to define mock.On call
func (_e *Table_Expecter) PeersCount() *Table_PeersCount_Call {
	return &Table_PeersCount_Call{Call: _e.mock.On("PeersCount")}
}

func (_c *Table_PeersCount_Call) Run(run func()) *Table_PeersCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Table_PeersCount_Call) Return(_a0 int) *Table_PeersCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_PeersCount_Call) RunAndReturn(run func() int) *Table_PeersCount_Call {
	_c.Call.Return(run)
	return _c
}

// PeersSpareCapacityForID provides a mock function with given fields: id
func (_m *Table) PeersSpareCapacityForID(id protocol.ID) int {
	ret := _m.Called(id)

	var r0 int
	if rf, ok := ret.Get(0).(func(protocol.ID) int); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Table_PeersSpareCapacityForID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PeersSpareCapacityForID'
type Table_PeersSpareCapacityForID_Call struct {
	*mock.Call
}

// PeersSpareCapacityForID is a helper method to define mock.On call
//   - id protocol.ID
func (_e *Table_Expecter) PeersSpareCapacityForID(id interface{}) *Table_PeersSpareCapacityForID_Call {
	return &Table_PeersSpareCapacityForID_Call{Call: _e.mock.On("PeersSpareCapacityForID", id)}
}

func (_c *Table_PeersSpareCapacityForID_Call) Run(run func(id protocol.ID)) *Table_PeersSpareCapacityForID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(protocol.ID))
	})
	return _c
}

func (_c *Table_PeersSpareCapacityForID_Call) Return(_a0 int) *Table_PeersSpareCapacityForID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_PeersSpareCapacityForID_Call) RunAndReturn(run func(protocol.ID) int) *Table_PeersSpareCapacityForID_Call {
	_c.Call.Return(run)
	return _c
}

// PutHash provides a mock function with given fields: id, peers, options
func (_m *Table) PutHash(id protocol.ID, peers []ktable.HashPeer, options ...ktable.HashOption) bool {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id, peers)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(protocol.ID, []ktable.HashPeer, ...ktable.HashOption) bool); ok {
		r0 = rf(id, peers, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Table_PutHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutHash'
type Table_PutHash_Call struct {
	*mock.Call
}

// PutHash is a helper method to define mock.On call
//   - id protocol.ID
//   - peers []ktable.HashPeer
//   - options ...ktable.HashOption
func (_e *Table_Expecter) PutHash(id interface{}, peers interface{}, options ...interface{}) *Table_PutHash_Call {
	return &Table_PutHash_Call{Call: _e.mock.On("PutHash",
		append([]interface{}{id, peers}, options...)...)}
}

func (_c *Table_PutHash_Call) Run(run func(id protocol.ID, peers []ktable.HashPeer, options ...ktable.HashOption)) *Table_PutHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]ktable.HashOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(ktable.HashOption)
			}
		}
		run(args[0].(protocol.ID), args[1].([]ktable.HashPeer), variadicArgs...)
	})
	return _c
}

func (_c *Table_PutHash_Call) Return(_a0 bool) *Table_PutHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_PutHash_Call) RunAndReturn(run func(protocol.ID, []ktable.HashPeer, ...ktable.HashOption) bool) *Table_PutHash_Call {
	_c.Call.Return(run)
	return _c
}

// PutPeer provides a mock function with given fields: id, addr, options
func (_m *Table) PutPeer(id protocol.ID, addr netip.AddrPort, options ...ktable.PeerOption) bool {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, id, addr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(protocol.ID, netip.AddrPort, ...ktable.PeerOption) bool); ok {
		r0 = rf(id, addr, options...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Table_PutPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutPeer'
type Table_PutPeer_Call struct {
	*mock.Call
}

// PutPeer is a helper method to define mock.On call
//   - id protocol.ID
//   - addr netip.AddrPort
//   - options ...ktable.PeerOption
func (_e *Table_Expecter) PutPeer(id interface{}, addr interface{}, options ...interface{}) *Table_PutPeer_Call {
	return &Table_PutPeer_Call{Call: _e.mock.On("PutPeer",
		append([]interface{}{id, addr}, options...)...)}
}

func (_c *Table_PutPeer_Call) Run(run func(id protocol.ID, addr netip.AddrPort, options ...ktable.PeerOption)) *Table_PutPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]ktable.PeerOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(ktable.PeerOption)
			}
		}
		run(args[0].(protocol.ID), args[1].(netip.AddrPort), variadicArgs...)
	})
	return _c
}

func (_c *Table_PutPeer_Call) Return(_a0 bool) *Table_PutPeer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_PutPeer_Call) RunAndReturn(run func(protocol.ID, netip.AddrPort, ...ktable.PeerOption) bool) *Table_PutPeer_Call {
	_c.Call.Return(run)
	return _c
}

// SampleHashesAndPeers provides a mock function with given fields:
func (_m *Table) SampleHashesAndPeers() ([]ktable.Hash, []ktable.Peer, int) {
	ret := _m.Called()

	var r0 []ktable.Hash
	var r1 []ktable.Peer
	var r2 int
	if rf, ok := ret.Get(0).(func() ([]ktable.Hash, []ktable.Peer, int)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []ktable.Hash); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ktable.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func() []ktable.Peer); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]ktable.Peer)
		}
	}

	if rf, ok := ret.Get(2).(func() int); ok {
		r2 = rf()
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// Table_SampleHashesAndPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SampleHashesAndPeers'
type Table_SampleHashesAndPeers_Call struct {
	*mock.Call
}

// SampleHashesAndPeers is a helper method to define mock.On call
func (_e *Table_Expecter) SampleHashesAndPeers() *Table_SampleHashesAndPeers_Call {
	return &Table_SampleHashesAndPeers_Call{Call: _e.mock.On("SampleHashesAndPeers")}
}

func (_c *Table_SampleHashesAndPeers_Call) Run(run func()) *Table_SampleHashesAndPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Table_SampleHashesAndPeers_Call) Return(_a0 []ktable.Hash, _a1 []ktable.Peer, _a2 int) *Table_SampleHashesAndPeers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Table_SampleHashesAndPeers_Call) RunAndReturn(run func() ([]ktable.Hash, []ktable.Peer, int)) *Table_SampleHashesAndPeers_Call {
	_c.Call.Return(run)
	return _c
}

// Stats provides a mock function with given fields:
func (_m *Table) Stats() ktable.Stats {
	ret := _m.Called()

	var r0 ktable.Stats
	if rf, ok := ret.Get(0).(func() ktable.Stats); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ktable.Stats)
	}

	return r0
}

// Table_Stats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stats'
type Table_Stats_Call struct {
	*mock.Call
}

// Stats is a helper method to define mock.On call
func (_e *Table_Expecter) Stats() *Table_Stats_Call {
	return &Table_Stats_Call{Call: _e.mock.On("Stats")}
}

func (_c *Table_Stats_Call) Run(run func()) *Table_Stats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Table_Stats_Call) Return(_a0 ktable.Stats) *Table_Stats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Table_Stats_Call) RunAndReturn(run func() ktable.Stats) *Table_Stats_Call {
	_c.Call.Return(run)
	return _c
}

// NewTable creates a new instance of Table. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTable(t interface {
	mock.TestingT
	Cleanup(func())
}) *Table {
	mock := &Table{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
